<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Last Night Automation - Full Description</title>
  <link href="https://fonts.googleapis.com/css2?family=Audiowide&display=swap" rel="stylesheet" />
  <style>
    html, body {
      margin: 0; padding: 0; overflow: hidden;
      background-color: black;
      height: 100vh;
    }
    canvas {
      display: block;
      background-color: black;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let width = canvas.width = window.innerWidth;
    let height = canvas.height = window.innerHeight;
    const centerX = width / 2;

    // Vertical starting position near top (10% down)
    const topStartY = height * 0.1;
    const lineHeight = 55; // space between lines

    window.addEventListener('resize', () => {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
      createTextTargets();
      assignTargets();
    });

    const offCanvas = document.createElement('canvas');
    const offCtx = offCanvas.getContext('2d');

    let targetPositions = [];

    // Multi-line description text for Last Night Automation
    const descriptionLines = [
      "LAST NIGHT AUTOMATION",
      "Software Suite for Precision",
      "System Monitoring, Updates,",
      "Backups, Security Scanning,",
      "And Automated Technician Tools",
      "Initiating precision... Standby for command."
    ];

    function createTextTargets() {
      offCanvas.width = width;
      offCanvas.height = height;
      offCtx.clearRect(0, 0, width, height);

      offCtx.fillStyle = '#fff';
      offCtx.font = 'bold 45px Audiowide';
      offCtx.textAlign = 'center';
      offCtx.textBaseline = 'middle';

      for (let i = 0; i < descriptionLines.length; i++) {
        offCtx.fillText(descriptionLines[i], centerX, topStartY + i * lineHeight);
      }

      const imageData = offCtx.getImageData(0, 0, width, height).data;

      targetPositions = [];
      for (let y = 0; y < height; y += 3) {
        for (let x = 0; x < width; x += 3) {
          const idx = (y * width + x) * 4;
          if (imageData[idx + 3] > 150) {
            targetPositions.push({ x, y });
          }
        }
      }
    }

    createTextTargets();

    class Particle {
      constructor() {
        this.x = Math.random() * width;
        this.y = Math.random() * height;
        this.vx = (Math.random() - 0.5) * 1.5;
        this.vy = (Math.random() - 0.5) * 1.5;

        this.tx = null;
        this.ty = null;
        this.state = 'scatter';

        this.colorDark = 'rgba(0, 51, 102, 0.8)';
        this.colorNeon = 'rgba(0, 187, 255, 1)';
        this.color = Math.random() < 0.5 ? this.colorDark : this.colorNeon;
      }

      update() {
        if (this.state === 'form' && this.tx !== null && this.ty !== null) {
          const dx = this.tx - this.x;
          const dy = this.ty - this.y;
          this.vx += dx * 0.02;
          this.vy += dy * 0.02;
          this.vx *= 0.85;
          this.vy *= 0.85;
        } else if (this.state === 'scatter') {
          this.vx += (Math.random() - 0.5) * 0.3;
          this.vy += (Math.random() - 0.5) * 0.3;
          this.vx *= 0.92;
          this.vy *= 0.92;
        } else if (this.state === 'expand') {
          const dx = this.x - centerX;
          const dy = this.y - topStartY - ((descriptionLines.length - 1) * lineHeight) / 2;
          this.vx += dx * 0.005;
          this.vy += dy * 0.005;
          this.vx *= 0.93;
          this.vy *= 0.93;
        } else if (this.state === 'return') {
          if (this.tx !== null && this.ty !== null) {
            const dx = this.tx - this.x;
            const dy = this.ty - this.y;
            this.vx += dx * 0.015;
            this.vy += dy * 0.015;
            this.vx *= 0.88;
            this.vy *= 0.88;
          } else {
            this.state = 'scatter';
          }
        }
        this.x += this.vx;
        this.y += this.vy;

        if (this.x < -50) this.x = width + 50;
        if (this.x > width + 50) this.x = -50;
        if (this.y < -50) this.y = height + 50;
        if (this.y > height + 50) this.y = -50;
      }

      draw() {
        ctx.beginPath();
        ctx.arc(this.x, this.y, 1.6, 0, Math.PI * 2);
        const grad = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, 6);
        grad.addColorStop(0, this.colorNeon);
        grad.addColorStop(0.6, this.colorDark);
        grad.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grad;
        ctx.shadowColor = this.colorNeon;
        ctx.shadowBlur = 10;
        ctx.fill();
      }
    }

    const PARTICLE_COUNT = 2200;
    const particles = [];
    for (let i = 0; i < PARTICLE_COUNT; i++) {
      particles.push(new Particle());
    }

    function assignTargets() {
      for (let i = 0; i < particles.length; i++) {
        particles[i].tx = targetPositions[i % targetPositions.length].x;
        particles[i].ty = targetPositions[i % targetPositions.length].y;
      }
    }

    assignTargets();

    let frame = 0;
    let state = 'scatter';

    function animate() {
      frame++;

      ctx.clearRect(0, 0, width, height);

      if (frame === 180) {       // after 3 sec
        state = 'form';
        particles.forEach(p => p.state = 'form');
      } else if (frame === 480) { // after 5 sec form
        state = 'expand';
        particles.forEach(p => p.state = 'expand');
      } else if (frame === 780) { // after 5 sec expand
        state = 'return';
        particles.forEach(p => p.state = 'return');
      } else if (frame === 1020) { // after 4 sec return
        state = 'scatter';
        particles.forEach(p => p.state = 'scatter');
        frame = 0;
      }

      particles.forEach(p => {
        p.update();
        p.draw();
      });

      requestAnimationFrame(animate);
    }

    animate();
  </script>
</body>
</html>
