<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Last Night Automation - Full Page Info</title>
  <link href="https://fonts.googleapis.com/css2?family=Audiowide&display=swap" rel="stylesheet" />
  <style>
    html, body {
      margin: 0; padding: 0; overflow: hidden;
      background-color: black;
      height: 100vh;
    }
    canvas {
      display: block;
      background-color: black;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let width = canvas.width = window.innerWidth;
    let height = canvas.height = window.innerHeight;
    const centerX = width / 2;

    window.addEventListener('resize', () => {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
      createTextTargets();
      assignTargets();
    });

    const offCanvas = document.createElement('canvas');
    const offCtx = offCanvas.getContext('2d');

    let targetPositions = [];

    // Full detailed info lines for Last Night Automation to fill the page vertically
    const descriptionLines = [
      "LAST NIGHT AUTOMATION",
      "The ultimate software suite designed for precision and efficiency.",
      "Features include:",
      "- Real-time system monitoring",
      "- Automated Windows updates with progress visualization",
      "- Secure and scheduled backups",
      "- Comprehensive malware and security scans",
      "- Transparent logo with live task progress",
      "- Voice integration and notifications",
      "- Designed for technicians to automate routine tasks",
      "Tools provided:",
      "- Directory watcher and backup utilities",
      "- Windows Defender scan integration",
      "- Windows Update automation",
      "- Notification system using Windows native toast alerts",
      "This software empowers IT professionals",
      "to maintain, update, and secure systems seamlessly.",
      "Initiating precision... Standby for command."
    ];

    function createTextTargets() {
      offCanvas.width = width;
      offCanvas.height = height;
      offCtx.clearRect(0, 0, width, height);

      offCtx.fillStyle = '#fff';
      offCtx.font = 'bold 36px Audiowide';
      offCtx.textAlign = 'center';
      offCtx.textBaseline = 'middle';

      const lineHeight = 50;
      const startY = height * 0.1; // start about 10% down from top

      for (let i = 0; i < descriptionLines.length; i++) {
        offCtx.fillText(descriptionLines[i], centerX, startY + i * lineHeight);
      }

      const imageData = offCtx.getImageData(0, 0, width, height).data;

      targetPositions = [];
      // Sample every 3 pixels horizontally and vertically for better density
      for (let y = 0; y < height; y += 3) {
        for (let x = 0; x < width; x += 3) {
          const idx = (y * width + x) * 4;
          if (imageData[idx + 3] > 150) {
            targetPositions.push({ x, y });
          }
        }
      }
    }

    createTextTargets();

    class Particle {
      constructor() {
        this.x = Math.random() * width;
        this.y = Math.random() * height;
        this.vx = (Math.random() - 0.5) * 1.5;
        this.vy = (Math.random() - 0.5) * 1.5;

        this.tx = null;
        this.ty = null;
        this.state = 'scatter';

        this.colorDark = 'rgba(0, 51, 102, 0.8)';
        this.colorNeon = 'rgba(0, 187, 255, 1)';
        this.color = Math.random() < 0.5 ? this.colorDark : this.colorNeon;
      }

      update() {
        if (this.state === 'form' && this.tx !== null && this.ty !== null) {
          const dx = this.tx - this.x;
          const dy = this.ty - this.y;
          this.vx += dx * 0.02;
          this.vy += dy * 0.02;
          this.vx *= 0.85;
          this.vy *= 0.85;
        } else if (this.state === 'scatter') {
          this.vx += (Math.random() - 0.5) * 0.3;
          this.vy += (Math.random() - 0.5) * 0.3;
          this.vx *= 0.92;
          this.vy *= 0.92;
        } else if (this.state === 'expand') {
          const dx = this.x - centerX;
          const dy = this.y - height / 2;
          this.vx += dx * 0.005;
          this.vy += dy * 0.005;
          this.vx *= 0.93;
          this.vy *= 0.93;
        } else if (this.state === 'return') {
          if (this.tx !== null && this.ty !== null) {
            const dx = this.tx - this.x;
            const dy = this.ty - this.y;
            this.vx += dx * 0.015;
            this.vy += dy * 0.015;
            this.vx *= 0.88;
            this.vy *= 0.88;
          } else {
            this.state = 'scatter';
          }
        }
        this.x += this.vx;
        this.y += this.vy;

        if (this.x < -50) this.x = width + 50;
        if (this.x > width + 50) this.x = -50;
        if (this.y < -50) this.y = height + 50;
        if (this.y > height + 50) this.y = -50;
      }

      draw() {
        ctx.beginPath();
        ctx.arc(this.x, this.y, 1.6, 0, Math.PI * 2);
        const grad = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, 6);
        grad.addColorStop(0, this.colorNeon);
        grad.addColorStop(0.6, this.colorDark);
        grad.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grad;
        ctx.shadowColor = this.colorNeon;
        ctx.shadowBlur = 10;
        ctx.fill();
      }
    }

    const PARTICLE_COUNT = 2800;  // more particles to fill full text area well
    const particles = [];
    for (let i = 0; i < PARTICLE_COUNT; i++) {
      particles.push(new Particle());
    }

    function assignTargets() {
      for (let i = 0; i < particles.length; i++) {
        particles[i].tx = targetPositions[i % targetPositions.length].x;
        particles[i].ty = targetPositions[i % targetPositions.length].y;
      }
    }

    assignTargets();

    let frame = 0;
    let state = 'scatter';

    function animate() {
      frame++;

      ctx.clearRect(0, 0, width, height);

      if (frame === 180) {       // after 3 seconds
        state = 'form';
        particles.forEach(p => p.state = 'form');
      } else if (frame === 600) { // after 7 seconds forming
        state = 'expand';
        particles.forEach(p => p.state = 'expand');
      } else if (frame === 1020) { // after 7 seconds expanding
        state = 'return';
        particles.forEach(p => p.state = 'return');
      } else if (frame === 1380) { // after 6 seconds returning
        state = 'scatter';
        particles.forEach(p => p.state = 'scatter');
        frame = 0;
      }

      particles.forEach(p => {
        p.update();
        p.draw();
      });

      requestAnimationFrame(animate);
    }

    animate();
  </script>
</body>
</html>
